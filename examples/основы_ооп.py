### OOP

# переменные класса:
class Point:
    "Описание класса"
    color = "red"
    circle = 2

# обращение и считывание соответственно: 
Point.color = "black"
Point.color

# словарь всех переменных класса:
Point.__dict__

# содержит строку с описанием класса:
Point.__doc__

# Переменные класса принадлежать только классу. К ним можно обратиться 
# через объекты, но сами объекты не будут их хранить в пространстве
# имен. a.__dict__ = {}. Но если присвоить переменной класса значение
# через объект, она добавиться отдельно в ее пространство имен
# a.color = "green"

setattr(Point, "название атрибута", "Значение атрибута")
getattr(Point, "название атрибута", "Возвращаемое значение")
del Point.color # удалит атрибут класса
# Если значение существует оно перезапишется, если не существет создастся

hasattr(Point, "название атрибута") # True - есть, False - нет
delattr(Point, "название атрибута") # удалит атрибут если он есть, если нет выйдет ошибка

# если обратиться к переменной класса через объект, то hasattr(Point, "название атрибута") может показать true, 
# т.к если нет атрибута в объекте, будет искать в классе(снизу в верх)

def method(self):
    print("Чего-нибудь")
    
# имя метода это атрибут
# self - ссылка на экземпляр класса(благодаря ему знаем с каким экземпляром класса мы работает)
Point.method() # не имеет ссылки на экземпляр класса, выдаст ошибку
Point.method(a) == a.method()  # эквивалентно

# При создании объекта срабатывает магический метод __new__, затем __init__ для инициализации переменных экземпляра класса

print(a.__dict__) # выведет переменные экземпляра класса в виде словаря

def __init__(self, x=0, y=0):
    something
    
a = Point() # теперь можно не указывать значения в скобках

__del__ # вызывается перед удалением объекта(когда на объект болбше нет внешних ссылок)


cls # ссылка на класс, а self на объект
__new__ # возвращает адрес нового созданного объекта 

# в python 3 все классы наследуются от класса obj