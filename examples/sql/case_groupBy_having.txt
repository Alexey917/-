Использовании функций агрегирования существует необходимость накладывать ограничения на возвращаемые ими результаты, именно это является одним 
из предназначений оператора HAVING. Еще одна возожность применения этого оператора — фильтрация результатов группировки строк на основании значений 
столбцов, указанных после оператора GROUP BY

Оператор HAVING синтаксически прописывается 
после оператора GROUP BY, но до оператора ORDER BY:
SELECT columnName1, columnName2, ...
FROM tableName
[WHERE condition]
[GROUP BY columnName1, columnName2, ...]
HAVING condition
[ORDER BY columnName1 ASC | DESC, ...]


SELECT
  ID,Name,Salary,

  CASE
    WHEN Salary>=3000 THEN 'ЗП >= 3000'
    WHEN Salary>=2000 THEN '2000 <= ЗП < 3000'
    ELSE 'ЗП < 2000'
  END SalaryTypeWithELSE,

  CASE
    WHEN Salary>=3000 THEN 'ЗП >= 3000'
    WHEN Salary>=2000 THEN '2000 <= ЗП < 3000'
  END SalaryTypeWithoutELSE

FROM Employees

WHEN-условия проверяются последовательно, сверху-вниз. При достижении первого удовлетворяющего условия дальнейшая проверка прерывается и возвращается значение, указанное после слова THEN, относящегося к данному блоку WHEN.

Если ни одно из WHEN-условий не выполняется, то возвращается значение, указанное после слова ELSE (что в данном случае означает «ИНАЧЕ ВЕРНИ …»).

Если ELSE-блок не указан и не выполняется ни одно WHEN-условие, то возвращается NULL.

И в первой, и во второй форме ELSE-блок идет в самом конце конструкции CASE, т.е. после всех WHEN-условий.

Вариант с LIF:
  SELECT
  ID,Name,Salary,

  IIF(Salary>=2500,'ЗП >= 2500','ЗП < 2500') DemoIIF,

  CASE WHEN Salary>=2500 THEN 'ЗП >= 2500' ELSE 'ЗП < 2500' END DemoCASE

FROM Employees


Конструкции CASE, IIF могут быть вложенными друг в друга. Рассмотрим абстрактный пример:

SELECT
  ID,Name,Salary,

  CASE
    WHEN DepartmentID IN(1,2) THEN 'A'
    WHEN DepartmentID=3 THEN
                          CASE PositionID -- вложенный CASE
                            WHEN 3 THEN 'B-1'
                            WHEN 4 THEN 'B-2'
                          END
    ELSE 'C'
  END Demo1,

  IIF(DepartmentID IN(1,2),'A',
    IIF(DepartmentID=3,CASE PositionID WHEN 3 THEN 'B-1' WHEN 4 THEN 'B-2' END,'C')) Demo2

FROM Employees


Для примера, пускай перед нами поставили задачу – создать список на выдачу ЗП на руки, следующим образом:

    Первым делом ЗП должны получить сотрудники у кого оклад меньше 2500
    Те сотрудники у кого оклад больше или равен 2500, получают ЗП во вторую очередь
    Внутри этих двух групп нужно упорядочить строки по ФИО (поле Name)



Попробуем решить эту задачу при помощи добавления CASE-выражение в блок ORDER BY:

SELECT
  ID,Name,Salary
FROM Employees
ORDER BY
  CASE WHEN Salary>=2500 THEN 1 ELSE 0 END, -- выдать ЗП сначала тем у кого она ниже 2500
  Name -- дальше упорядочить список в порядке ФИО


И абстрактный пример использования CASE в блоке WHERE:

SELECT
  ID,Name,Salary
FROM Employees
WHERE CASE WHEN Salary>=2500 THEN 1 ELSE 0 END=1 -- все записи у которых выражение равн


Агрегатные функции

Здесь мы рассмотрим только основные и наиболее часто используемые агрегатные функции:
Название 	Описание
COUNT(*) 	Возвращает количество строк полученных оператором «SELECT … WHERE …». В случае отсутствии WHERE, количество всех записей таблицы.
COUNT(столбец/выражение) 	Возвращает количество значений (не равных NULL), в указанном столбце/выражении
COUNT(DISTINCT столбец/выражение) 	Возвращает количество уникальных значений, не равных NULL в указанном столбце/выражении
SUM(столбец/выражение) 	Возвращает сумму по значениям столбца/выражения
AVG(столбец/выражение) 	Возвращает среднее значение по значениям столбца/выражения. NULL значения для подсчета не учитываются.
MIN(столбец/выражение) 	Возвращает минимальное значение по значениям столбца/выражения
MAX(столбец/выражение) 	Возвращает максимальное значение по значениям столбца/выражения


Подведем некоторые итоги:

    COUNT(*) – служит для подсчета общего количества строк, которые получены оператором «SELECT … WHERE …»
    во всех остальных вышеперечисленных агрегатных функциях при расчете итога, NULL-значения не учитываются
    если нам нужно учесть все строки, это больше актуально для функции AVG, то предварительно необходимо осуществить обработку NULL значений, например, как было показано выше «AVG(ISNULL(Salary,0))»



Из основного, стоит отметить, что в случае группировки (GROUP BY), в перечне колонок в блоке SELECT:

    Мы можем использовать только колонки, перечисленные в блоке GROUP BY
    Можно использовать выражения с полями из блока GROUP BY
    Можно использовать константы, т.к. они не влияют на результат группировки
    Все остальные поля (не перечисленные в блоке GROUP BY) можно использовать только с агрегатными функциями (COUNT, SUM, MIN, MAX, …)
    Не обязательно перечислять все колонки из блока GROUP BY в списке колонок SELECT



HAVING – наложение условия выборки к сгруппированным данным

Собственно, если вы поняли, что такое группировка, то с HAVING ничего сложного нет. HAVING – чем-то подобен WHERE, только если WHERE-условие применяется к детальным данным, то HAVING-условие применяется к уже сгруппированным данным. По этой причине в условиях блока HAVING мы можем использовать либо выражения с полями, входящими в группировку, либо выражения, заключенные в агрегатные функции.



Конструкция/Блок 	Порядок выполнения 	Выполняемая функция
SELECT возвращаемые выражения 	4 	Возврат данных полученных запросом
FROM источник 	0 	В нашем случае это пока все строки таблицы
WHERE условие выборки из источника 	1 	Отбираются только строки, проходящие по условию
GROUP BY выражения группировки 	2 	Создание групп по указанному выражению группировки. Расчет агрегированных значений по этим группам, используемых в SELECT либо HAVING блоках
HAVING фильтр по сгруппированным данным 	3 	Фильтрация, накладываемая на сгруппированные данные
ORDER BY выражение сортировки результата 	5 	Сортировка данных по указанному выражению