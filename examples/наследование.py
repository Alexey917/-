### Наследование

class Geom:
    name = "Geom"
    
    def set_coords(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        
    def draw(self):
        print("Рисовать примитивы")
    
class Line(Geom):
    def draw(self):
        print("Рисовать линии")
        
class Rect(Geom):
    def draw(self):
        print("Рисовать прямоугольники")
        
g = Geom()
l = Line()
r = Rect()

# l.set_coords ищется сначало в своем классе(Line), если не найдется, то идет искать в родителе

l.set_coords(0, 0, 0, 0)

# Если метод или атрибут есть у родителя и дочернего класса - это будет называться переопределением

l.draw()
r.draw()

# Наследование - один класс определяется на основе другого


# Экземпляры дочерних классов могут обращаться к своим и родительским атрибутам и методам, а родительские только к своим

# self - ссылка на экземпляр как своего, так и дочернего класса

# Любой класс наследуется от класса object

# вызывая print вызывается метод __str__ класса object

issubclass("Дочерний", "Базовый") # определяется является ли класс подклассом. Эта функция работает только с классами

isinstance("объект/класс", "класс") # проверка на принадлежность объекта классу. Тут классы можно тоже проверять

# Встроенные типы данных - это подклассы класса object

super() # возвращает объект-ссылку на объект посредник, через который происходит вызов базового класса

# Делегирование - вызов методов базового класса через super()

# инициализатор базового класса вызывается сразу, иначе будет переопределение свойства
class Geom:
    name = "Geom"
    
    def __init__(self, x1, y1, x2, y2):
        self.x1 = x1
        self.y1 = y1
        self.x2 = x2
        self.y2 = y2
        
    def draw(self):
        print("Рисовать примитивы")
    
class Line(Geom):
    def __ini__(self, fill=None):
        super().__init__(x1, y1, x2, y2) # <- тут сразу - правильно
        self.fill = fill
        #super().__init__(x1, y1, x2, y2) <- тут  не сразу - не правильно

_name # protected - можно обращаться внутри класса и в других классах. Лишь предостерегает программиста, что свойство защищено, явной защиты не дает.

__name # private - обращаться можнео только внутри текущего класса

# интерфейсные методы: геттеры и сеттеры

# модуль для более лучшей защиты чем 2 нижних подчеркивания
from acceffify import private, protected
# После установки(нужно скачать) можно использовать два декоратора: private и protected

# Через accessify нельзя обратиться к защищенным методам или свойствам, с __ можно через специальное имя(префикс в виде класса в котором применен атрибут), которое можно узнать с помощью команды print(dir("экземпляр")). Чаще всего __ достаточно для защиты
